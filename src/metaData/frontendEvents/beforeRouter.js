export default "window.beforeRouter = async (event) => { \nawait (async () => {\n    /* 本逻辑为PC端事件逻辑——如无必要，请勿删改\n\n本逻辑作用：\n\n当PC端页面切换前，会执行本事件逻辑\n\n判断当前访问用户是否对即将访问的页面具有权限，如无权限则跳转处理。\n\n如有需要，开发者可变更处理方式\n */;\n    await (async () => {\n            // Vue2\n// 初始全部导入权限路径的方式\nconst { \n    router, \n    routes, \n    baseResourcePaths,\n    authResourcePaths,\n    appConfig, \n    beforeRouter, \n    filterRoutes,\n    to, \n    from, \n    next, \n    parsePath, \n    getBasePath, \n    filterAuthResources, \n    findNoAuthView\n} = event;\n\nconst redirectedFrom = parsePath(to.redirectedFrom);\nconst toPath = redirectedFrom && redirectedFrom.path || to.path;\nconst toQuery = to.query;\n\nconst rootPaths = [\n  '/', \n  `${getBasePath()}`, \n  `${getBasePath()}/`\n];\n\nconst authPath = authResourcePaths.find((authResourcePath) => {\n    if (authResourcePath === toPath || `${authResourcePath}/` === toPath) {\n        return true;\n    }\n    return false;\n});\n\n/**\n * 第一次进路由守卫时就载入全部权限路由\n */\nif (authResourcePaths?.length && !checkAuthPathsInjected(router, authResourcePaths)) {\n    // 载入全部路由\n    const resources = authResourcePaths.concat(baseResourcePaths).map(route => ({\n        resourceValue: route,\n    }));\n\n    const authResources = filterAuthResources(resources);\n    addAuthRoutes(authResources);\n\n    return next({\n        path: toPath,\n        query: toQuery,\n        replace: true,\n    });\n}\n\n// 始终获取用户权限资源\nawait window.$auth.getUserResources(appConfig.domainName);\n\n// 需要权限\nif (authPath) {\n    const userInfo = await window.$auth.getUserInfo()\n    // 未登录\n    if (!userInfo || !userInfo.UserId) {\n        localStorage.setItem('beforeLogin', JSON.stringify(location));\n        \n        return next({ \n            path: `${getBasePath()}/login` \n        });\n    }\n\n    let hasPermission = window.$auth.has(authPath);\n    if (rootPaths.includes(authPath)) {\n        hasPermission = true;\n    }\n\n    // 没权限\n    if (!hasPermission) {\n        const noAuthView = findNoAuthView(routes);\n        return next({\n            path: noAuthView.path,\n        })\n    }\n}\n\nreturn next();\n\n// 工具函数\nfunction checkAuthPathsInjected(router, authResourcePaths = []) {\n  // 只要有一个权限路径被注入路由，就返回 true\n  return authResourcePaths\n    .filter(path => !rootPaths.includes(path))\n    .some((authResourcePath) => {\n      return router.getRoutes().some((route) => {\n          const routePath = route.path;\n          return routePath === authResourcePath || `${routePath}/` === authResourcePath;\n      });\n  });\n}\n\n// 工具函数\nfunction normalizePath(path) {\n    return path.endsWith('/') ? path : `${path}/`;\n}\n// 工具函数\nfunction addAuthRoutes(resources) {\n    if (Array.isArray(resources) && resources.length) {\n        const userResourcePaths = (resources || []).map((resource) => resource && resource.resourceValue || resource && resource.ResourceValue);\n        const otherRoutes = filterRoutes(routes, null, (route, ancestorPaths) => {\n            const routePath = route.path;\n            const completePath = [...ancestorPaths, routePath].join('/');\n            const authPath = userResourcePaths.find((userResourcePath) => {\n                if (userResourcePath) {\n                    const l1 = normalizePath(userResourcePath).split('/');\n                    const l2 = normalizePath(completePath).split('/');\n                    let bool = true;\n                    \n                    for (let i = 0; i < l2.length; i++) {\n                        if (l2[i] !== l1[i]) {\n                            bool = false;\n                            break;\n                        }\n                    }\n\n\n                    return bool;\n                }\n\n\n                return false\n            });\n            return authPath;\n        });\n\n\n        otherRoutes.forEach((route) => {\n            router.addRoute(route);\n        });\n    }\n}\n        })();;\n})();\n}\n";
